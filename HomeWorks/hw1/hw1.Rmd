---
title: "Домашняя работа №1"
author: "Nikitin Dmitry RI-450004"
date: '26 сентября 2018 г '
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Работа с данными.
1. Загрузите данные в датафрейм.
```{r}
data.df <- read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
```
2. Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.
```{r}
nrow(data.df)
ncol(data.df)
```
3. Получите имена колонок из датафрейма.
```{r}
colnames(data.df)
```
4. Найдите значение из 5 строки седьмого столбца.
```{r}
data.df[5,7]
```
5. Напечатайте целиком 2 строку из датафрейма.
```{r}
data.df[2,]
```
6. Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
head(data.df)
tail(data.df)
```
Эта строка присваивает имена колонкам датафрейма, последние 24 колонки - количество осадков за определенный час, номер котрого равен названию столбца.
7. Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?
```{r}
data.df<-cbind(data.df, daily=c(rowSums(data.df[4:27])))
hist(data.df[,"daily"], prob=TRUE, main = "Гистограмма осадков",xlab="Количество осадков")
```
Гистограмма не предоставляет адекватных сведений, т.к. в датафрейме встречаются отрицательные значения.
8.Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.
```{r}
fixed.df <- subset(data.df,data.df[,"daily"]>=0)
hist(fixed.df[,"daily"], prob = TRUE, main = "Гистограмма осадков",xlab="Количество осадков")
```
Из данных было исключено подмножество отрицательных значений и теперь гистограмма не противоречит здравому смыслу.
## Синтаксис и типизирование
1. Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.
Создание вектора
```{r}
v <- c("4", "8", "15", "16", "23", "42")
```
Поиск максимального элемента в векторе, в данном случае строки которая больше всех с точки зрения расположения символов в алфавите.
```{r}
max(v)
```
Сортировка элементов массива в алфавитном порядке.
```{r}
sort(v)
```
Строка sum(v) - ошибочна, так как в R к строкам не применимо сложение.
2. Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.
Создание вектора и неявный каст числового типа к типу character так как вектор должен содержать элементы одного типа.
```{r}
v2 <- c("5",7,12)
```
Строка v2[2] + 2[3] - операция сложения не применима к типу character. Создание датафрейма.
```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
```
Сложение второго и третьего элемента превой строки датафрейма. Сложение срабатывает так как столбцы датафрейма могут иметь разные типы и при создании каста к character не происходит.
```{r}
df3[1,2] + df3[1,3]
```
Создание списка.
```{r}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
```
Сложение 2ого и 4ого элементов списка. Обращение к элементу происходит с помощью оператора [[]].
```{r}
l4[[2]] + l4[[4]]
```
l4[2] + l4[4] - в этой строке с помощью операции [] получаются 2 слайса, но оператор + может быть применен только к числовым операндам.
## Работа с функциями и операторами
1. Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
Числа от 1 до 10000 с инкрементом 372. 
```{r}
seq(1, 10000, by=372)
```
Числа от 1 до 10000 длиной 50.
```{r}
seq(1, 10000, length.out=372)
```
2. Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.
Повторяет последовательность переданную в качестве первого аргумента заданное число раз
```{r}
rep(1:5,times=3)
```
Потворяет каждый элемент из последовательности заданное число раз
```{r}
rep(1:5, each=3)
```

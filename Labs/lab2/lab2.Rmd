---
title: "Lab_2"
author: "Nikitin Dmitry RI-450004"
date: '4 октября 2018 г '
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Загрузка данных датафрейма
```{r}
library(MASS)
data(Cars93)
```
Ознакомление сос труктурой и составом данных
```{r}
View(Cars93)
```
### Задание 1
1. Выполнение summary() на полном наборе данных
```{r}
summary(Cars93)
nrow(Cars93)
```
summary не дает информцию о количестве строк в датафрейме, вместо эттого можно использовать команду nrow() - результат 93 строки.
2. Средняя цена автомобилей с задним приводом
```{r}
mean(subset(Cars93$Price,Cars93$DriveTrain=="Rear"))
```
3. Минимальное число лошадей для машин с 7, 6 пассажирами
```{r}
min(subset(Cars93$Horsepower,Cars93$Passengers=="7"))
min(subset(Cars93$Horsepower,Cars93$Passengers=="6"))

```
4. Найти машины с минимальным, максимальным и средним расстоянием, которая машина может проехать по трассе. Для этого необхродимо знать расход топлива на милю по трасе - ``MPG.highway`` и емкость бака машины - ``Fuel.tank.capacity``.
```{r}
Cars93 <- cbind(Cars93, distances =Cars93$MPG.highway*Cars93$Fuel.tank.capacity)
max<-Cars93[Cars93$distances == max(Cars93$distances) ,]
medium<-Cars93[Cars93$distances == median(Cars93$distances) ,]
min<-Cars93[Cars93$distances == min(Cars93$distances) ,]
min
medium
max

```
## Задание 2
Код отвеающий за оптимизацию производства
```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    message(steps)
    print(needed)
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  
  return(list(steps, needed, output))
}
```
1. Выполните код и запустите эту функцию ``factory.run()``.
```{r}
factory.run()
```
2. С каким входными значениями функция вызвана? Какой получился результат?
Входные значения по умолчанию 1 автомобиль, 1 грузовик. Выход - Максимальное количество автомобилей и грузовиков, которые  могут быть выпущены при текущих объмах материалов на складе - автомобили  грузовики 
  9.978995  19.890611 
3. Повторите вызов 4 раза. Полученные ответы отличаются от полученнымх ранее? Если да, почему? Если нет, почему?
Да так как в случае когда потребление одного ресурса потреблено слишком много, а другого недостаточно, мы увеличиваем план на случайную величину, что приводит к разным результатам на выходе.
4. В приведённом коде, переменные _steps_ и _output_ находятся внутри алгоритма.
Измените функцию так, чтобы она возвращала число шагов и произведённое количество машин.
Для этого можно возвращать список значений. см. код отещающий за оптимизацию производства
5. Установите план равный тридцати автомобилям и 20 грузовикам и выполните функцию.
```{r}
factory.run(30, 20)
```
   1. Какой получили результат?
   автомобили  грузовики 
   10.23479   19.84233
   2. Каким получился итоговый запрос ресурсов (переменная _needed_)
   трудодни 1599.93150
   сталь      69.76178
   3. Как много итераций пришлось пройти, чтобы получить ответ (переменная _steps_)? 806
   4. Для подсчёта можно пользоваться функциями печати (``print``, ``message``) или вернуть результат из функции.